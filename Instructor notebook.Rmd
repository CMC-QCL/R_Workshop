---
title: "R Workshop Notebook"
output: html_notebook
editor_options: 
  markdown: 
    wrap: 72
---

# Intro

## Learning goals

-   R studio environment
-   Basics of R-programming
-   Data manipulation and visualization

This workshop *No one gets left behind*

## Icebreaker

*Who has coded before/scared of coding*

## R Studio Vs Posit Cloud

Posit: - Go to <http://www.posit.cloud/plans/free> -\> sign up

*Here we open R new project because it takes a few seconds to create in
cloud*

## What is R, What is good for:

Programming language specialized in data manipulation

Processing data and mathematical calculations, Data wrangling,
manipulation and visualization.

*Shows the Palmer penguins report*

## Life-cycle of data analysis

![](images/clipboard-3789389711.png){width="339"}

**Tidy:** storing data in a consistent form that matches the semantics
of the dataset with how it is stored. In brief, when your data is tidy,
each column is a variable and each row is an observation

**Transformation** includes narrowing in on observations of interest

**tidying and transforming** are called wrangling

To communicate we can create reports

# Setup

## Explore the platform

4 Main sections

-   **Source Editor** (Top Left)

-   **Console** (Bottom Left)

-   **Environment & History** (Top Right) + Connections, GIT

-   **Files, Plots, Packages, Help & Viewer** (Bottom Right

### Console and terminal

*Start working here*

# Get started

Name your new project

## Running R code (console)

You can directly run code in your console like

```{r}
1+1
2*3 # Use * for multiplication
-10/5 # ignore horizontal white space after the first digit
4^2 # Power notation carrot, number on the right exponent
pi # built-in numeric object to represent mathematical constant
# 2pi  # syntax Error
2*pi

```

Let's calculate the mean

```{r}
4 + 5 + 6 / 3 # -> Wrong, order of operations
(4 + 5 + 6) / 3

```

## Functions

Are self-contained blocks of code that perform a specific task, take
inputs called arguments (inside a set of parenthesis), process them, and
return a result. They are a fundamental building block for modular and
reusable code in R programming

R has a large collection of built-in functions that are called like
this:

`function_name(argument1 = value1, argument2 = value2, ...)`

Other R objects (such as data or function arguments) without
parentheses, like penguins or x.

let's look at the *round* function

```{r}
round(5.226)
```

Function help `?function_name`

```{r}
?round()
```

```{r}
round(x=5.226, digits=2)
```

We often omit the names of the first several arguments in function
calls, but it is important to retain the order, so we can rewrite this
as follows:

*Go back to your previous commands using up/down arrows.*

*Type the first part of the command then cmd+arrow for partial match*

```{r}
round(5.222, 2)
```

*R provides assistance closing parentheses and quotations, demonstrate
what happens when executing an incomplete command `round(5.2`*

```{r}
"hello"
```

We have different Data types in R, and we store them as objects. Some of
the most popular type of basic data we interact are integers \<int\>,
decimals \<dbl\>, strings \<str\>, or boolean \<bol\> (logical)

## Atomic Data types

There are different atomic data types for each operation

-   int
-   dbl - real -\> Numeric
-   Complex
-   chr - strings
-   dttm -\> datetime
-   Logical

### Operation on different atomic data

```{r}
#Functions operate on specific data types
sin(pi/2)
#sin("pi")
#3*"pi"
cos (pi/2) # Numerical error, explain exponential notation
1 - cos(pi/2)
is.integer(1 - cos(pi/2))
as.integer(1 - cos(pi/2))
round(1 - cos(pi/2))

#binary logical operations can be represented with 0 and 1
# TRUE FALSE is object of the logical data type
FALSE & TRUE
FALSE | TRUE
# Is not the same as having
FALSE * TRUE
FALSE + TRUE + TRUE
```

## Data Structures

These atomic data types are the *building blocks* for more complex R
data structures, such as:

**Vectors:** One-dimensional arrays that can hold multiple elements of
the same atomic data type.

command to ***c**reate `c(arguments)`*

**Matrices**: Two-dimensional collections of elements of the same atomic
data type.

`matrix( c(1, 2, 3, 4), nrow = 2 )`

**Arrays**: Multi-dimensional collections of elements of the same atomic
data type.

`array(data = 1:12, dim = c(2, 3, 2))`

**Lists**: Generic one-dimensional collections that can contain elements
of different data types (e.g., a character vector, a numeric vector, and
another list).

`list("Alice", 1, 2, 3.1416, matrix(c(1, 2, 3, 4), nrow=2))`

**Factors:** A special type of character vector used to store
categorical data with predefined levels.

```{r}
factor(c("red", "green", "blue", "blue", "red"))
```

**Data Frames**: The most important data structure for statistics in R,
acting as a tabular, *two-dimensional structure* where each **column**
can have a *different data type*, but all **columns** must have the
*same length*.

We are going to dive deeper in this type of data later.

```{r}
data.frame(
  id = c(10012, 10013, 10014),
  name = c("Ana", "John", "Joann"),
  gpa = c(3.1, 3, 3.11122333)
  )
```

*\*make connections with output*

### Operations on data structure

We can execute basic operations on data structures like vectors

```{r}
3*c(10, 20, 30)
```

or execute functions, this function expects an object, not a set of
numbers

```{r}
mean(1, 2, 3, 4) # Wrong, mean is expecting an object
mean(c(1, 2, 3, 4))

# generate random numbers (uniform distribution)
runif(5)
mean(runif(10000))
```

# Notebook

Create a new notebook and explain how it works

## Markdown

Markup language for creating formatted text using a plain-text editor.
It is useful because it lets us combine code for text formatting and
execute chunks of code.

we use \# to symbolize sections like using levels of headers and
subheaders

We use - to create pointers

We use single \` backticks to symbolize `code`

We use \`\`\` Back-ticks to enclose code chunks

we use brackets { } to comment **what language** the chunk is written in
**how the chunk should behave** (show code, hide code, etc.)

```{{language, settings}}
# Code comments
code section

```

In a notebook I am **interacting with my current environment** , the
libraries and objects created are the same as my notebook is using
currently through my console commands.

```{r}
3*3*3*3 #Show how the code is executed in the console
```

Use **comments** to explain the *why* of your code, not the *how* or the
*what*. The what and how of your code are always possible to figure out,
even if it might be tedious, by carefully reading it

For *data analysis code*, use comments to explain your *overall plan of
attack* and record *important insights* as you encounter them. There’s
no way to re-capture this knowledge from the code itself.

# Create new objects (operator `<-` )

At the heart of almost everything you will do (or ever likely to do) in
R is the concept that everything in R is an **object**. These objects
*can be almost anything*, from a single number or character string (like
a word) to highly complex structures like the output of a plot, a
summary of your statistical analysis or a set of R commands that perform
a specific task.

*The term "object" in R refers to any data structure that can be
manipulated and assigned to a variable name using the assignment
operator*

To create an object we simply give the object a name. We can then assign
a value to this object using the *assignment operator* (gets).

Note that the value of the object is not printed, it's just stored. Now
that we’ve created this object, R knows all about it and will keep track
of it during this current R session. To see the value type the name of
it in the console.

With objects you can take data out of them, do computations and store
the results in another object.

*Make descriptive object names*

```{r}
square_root_pi <- sqrt(pi)
```

```{r}
id <- c(10012, 10013, 10014)
name <- c("Ana", "John", "Joann")
gpa <- c(3.1, 3, 3.11122333)
```

```{r}
#Create a dataframe
data.frame(
  id, 
  name,
  gpa
  )
```

# Install libraries

e.g. install.packages("name_of_the_library)

```{r}
#  install.packages("tidyverse")
```

An R package is a collection of libraries with functions, data, and
documentation that extends the capabilities of base R

Note the Quotation marks -\> strings

## Load libraries

e.g library(name_of_the_library)

Let's try calling objects from the installed packages

```{r}
# ggplot() doens't execute becaus eit is not loaded
```

Load libraries

```{r}
library(palmerpenguins) #Try leaving it uninstalled first
library(tidyverse)
```

Sometimes, to make it clear which package an object comes from, we can
use the package name followed by two colons, like dplyr::mutate() or
nycflights13::flights. This is also valid R code.

# Dataframes

A **data-frame** is a rectangular collection of variables (in the
columns) and observations (in the rows).

A **variable** is a *quantity, quality,* or *property* that you can
measure. The first row of a *data-frame* is the name of the variable

*What do you think is a variable we can measure in penguins.*

A **value** is the state of a variable when you measure it. The value of
a variable may change from measurement to measurement.

An **observation** is a set of measurements made under similar
conditions (you usually make *all of the measurements* in an observation
at the same time and on the same object).

An observation will contain several values, each associated with a
different variable. We’ll sometimes refer to an observation as a data
point.

**Tabular data** is a set of values, each associated with a *variable*
and an *observation*. Tabular data is **tidy** if each value is placed
in its own “cell”, each variable in its own column, and each observation
in its own row.

In R type the name of the data frame in the console to print it's
contents.

```{r}
penguins # if it fails install the library
```

In the tidyverse, we use special data frames called tibbles, a
**tibble** is a **modern version of a data frame** created by the
**tidyverse**.

-   Tibbles print politely.

-   Tibbles show data types right under column names

-   No partial matching (this prevents bugs)

-   Strings are not automatically converted to factors

-   Tibbles are stricter but more consistent

For an alternative view, where you can see all variables vertically, and
the first few observations of each variable:

```{r}
glimpse(penguins)
```

Or open an interactive data viewer

```{r}
# View(penguins) *and close thw view tab
```

Our ultimate goal is to discover a relationship between flipper lengths
and body masses of these penguins, taking into consideration the species
of the penguin.

# Creating a ggplot \<Skip this section\>

### Help

```{r}
?ggplot
```

### Create canvas and add layers

```{r}
ggplot(data = penguins)
```

### Data representation

We need to tell ggplot() how the information from our data will be
visually represented. The mapping argument of the ggplot() function
defines how variables in your dataset are mapped to visual properties
(aesthetics) of your plot. The mapping argument is always defined in the
aes() function, and the x and y arguments of aes() Lets map flipper
lenght vs body mass

```{r}
ggplot(
  data = penguins,
  mapping = aes(x = flipper_length_mm, y = body_mass_g)
)
```

### define a geom for scatterplot

The geometrical object that a plot uses to represent data. We ususally
describe plots by the type of geom that the plot uses. Start with geom\_
-\> geom_bar(), geom_line(), geom_boxplot(), geom_point()

```{r}
ggplot(
  data = penguins,
  mapping = aes(x = flipper_length_mm, y = body_mass_g)
) +
  geom_point()
```

Speak about warning, missing values should never silently go missing

### Adding aesthetic layers

It’s always a good idea to be skeptical of any apparent relationship
between two variables and ask if there may be other variables that
explain or change the nature of this apparent relationship. How the
species influence this relationship

```{r}
ggplot(
  data = penguins,
  mapping = aes(x = flipper_length_mm, y = body_mass_g, color = species)
) +
  geom_point()
```

When a categorical variable is mapped to an aesthetic, ggplot2 will
automatically assign a unique value of the aesthetic to each unique
level of the variable Also add a legend

### Smooth curve

Display relationship between bm and fl Since this is a new geometric
object representing our data, we will add a new geom as a layer on top
of our point geom: geom_smooth(). And we will specify that we want to
draw the line of best fit based on a linear model with method = "lm".

```{r}
ggplot(
  data = penguins,
  mapping = aes(x = flipper_length_mm, y = body_mass_g, color = species)
) +
  geom_point() +
  geom_smooth(method = "lm")
```

When aesthetic mappings are defined in ggplot(), at the global level,
they’re passed down to each of the subsequent geom layers of the plot.
each geom function in ggplot2 can also take a mapping argument, which
allows for aesthetic mappings at the local level

```{r}
ggplot(
  data = penguins,
  mapping = aes(x = flipper_length_mm, y = body_mass_g)
) +
  geom_point(mapping = aes(color = species)) +
  geom_smooth(method = "lm")
```

### Shape aesthetics

It’s generally not a good idea to represent information using only
colors on a plot, as people perceive colors differently due to color
blindness or other color vision differences. Therefore, in addition to
color, we can also map species to the shape aesthetic.

```{r}
ggplot(
  data = penguins,
  mapping = aes(x = flipper_length_mm, y = body_mass_g)
) +
  geom_point(mapping = aes(color = species, shape = species)) +
  geom_smooth(method = "lm")
```

### Improve labels

```{r}
ggplot(
  data = penguins,
  mapping = aes(x = flipper_length_mm, y = body_mass_g)
) +
  geom_point(aes(color = species, shape = species)) +
  geom_smooth(method = "lm") +
  labs(
    title = "Body mass and flipper length",
    subtitle = "Dimensions for Adelie, Chinstrap, and Gentoo Penguins",
    x = "Flipper length (mm)", y = "Body mass (g)",
    color = "Species", shape = "Species"
  ) # + scale_color_colorblind()
```

### body mass by species boxplot

Note that the name of the arguments can be skipped, but this makes more
difficult reading the code

```{r}
ggplot(
  penguins, 
  aes(species, body_mass_g, fill = species)) +
  geom_boxplot()
```

### Frequencies of each species of penguins on each island

```{r}
ggplot(penguins, aes(x = island, fill = species)) +
  geom_bar()
```

# Exercise

## Section 1: Gather observations

Lets create our own dataframe, lets start by making an observation of
the people in this room. let's answer how much time have you spent on
social media this week.

Let's store the values on different objects

```{r}
# Create objects for time on social media with their answers
time1_on_soc_media <- 5
time2_on_soc_media <- 6
time3_on_soc_media <- 7
# Use option - to insert assignment symbol
avg_time_on_soc_media <- (time1_on_soc_media + time2_on_soc_media + time3_on_soc_media)/3
avg_time_on_soc_media
```

Case sensitive

```{r}
# Average_time_on_social_media
```

*Is there a more efficient way to do this?*

## Combine elements

Value can be assigned to an object as a single or as a vector.
**C**ombine elements with function c()

```{r}
time_on_social_media <- c(time1_on_soc_media, time2_on_soc_media, time3_on_soc_media)
```

## Access indexed elements on vectors

Vector stores different values and are indexed [:] (1 indexed in R)

```{r}
time_on_social_media[0]
time_on_social_media[1]
time_on_social_media[3]
time_on_social_media[4]
time_on_social_media[2:4] # introduce range concept
```

NA -\> Not available/missing value

## Assign indexed value

```{r}
time_on_social_media[2] <- 65.5
time_on_social_media[4] <- 67
time_on_social_media[8] <- 70.5
time_on_social_media
time_on_social_media[2:8] 
```

## Operating on vectors

Convert hr -\> min

```{r}
# Convert hours into minutes
time_on_social_media_s <- time_on_social_media * 60
time_on_social_media_s
```

Use some pre-defined functions

```{r}
# Not all functions work with empty values
sum(time_on_social_media_s)
length(time_on_social_media_s)
median(time_on_social_media_s)
mean(time_on_social_media_s)
is.na(time_on_social_media_s)
mean(time_on_social_media_s, na.rm = TRUE)

```

## Access elements on a dataset

```{r}
# Quick command to access one column with the name (partial matching so it can be risky)
head(penguins$body_mass_g)
```

We can also access a specific item of the column

```{r}
penguins$body_mass_g[2]
penguins$body_mass_g[2:5]
```

## Access an indexed range column

```{r}
# Display using indexed columns
penguins[, 1:3] # First element reserved for rows
penguins[1, 1:3] 
```

```{r}
# We can pass column names as arguments 
penguins[,c("species", "island", "body_mass_g")]
```

## Import elements

**From data import:** upload some dataset related to students

-   gpa

-   student_sleep

Import dataset

```{r}
gpa <- read.csv("Data/gpa.csv")
```

## 

## GGPlot (Optional) \<if previous was skipped\>

```{r}
# Line by line paint the canvas
ggplot(
  # print empty canvas, time to check for ?ggplot
  data=penguins, 
  # Time to check for ?aes
  aes(species, body_mass_g # break for partial execution. ggplot needs a categorical x (or group) to split box-plots [factor]
    , fill = species)) + # This should be the last line 
  geom_boxplot()

```

# R Markdown

Open a new markdown file Markdown is a simple formatting syntax for
authoring HTML, PDF, and MS Word documents. For more details on using R
Markdown see <http://rmarkdown.rstudio.com>.

Why and when do we use *markdown* or *notebook*?

Knit will execute all the code in the document on a separated
environment

What were the steps that we took to create our dataset?

prepare environment, import, collect data, tidy, transform data,
visualize, communicate

Header section, we put the library load here so it wont be seen in the
output

```{{r setup, include=FALSE}}
knitr::opts_chunk$set(echo = TRUE)

library(tidyverse) # run this first on a separated block
```

```         
# Section 1

## Intro
This is a demonstration for the classroom observations

## Data definition
```

***knit***

```{r}
students <- c("student1", "student2", "student3", "student4", "student5", "student6", "student7", "student8")
length(students)
```

***knit***

Code chunks executed with inline code executed

We have a total of `r length(students)` observations

```{r}
student_heights <- c(5, 65, 7, 67, NA, NA, NA, 70)

```

***Knit***

Output is not shown, I am only creating an object

## Create dataframe

Exercise for students: Create a report that demonstrates the data
analysis lyfe-cycle, use the objects from the in-class observations and
the imported ones to create your dataframe, and then do some data
analysis and come up with some conclusions, use graphics if possible.

```{r}
student_survey_df <- data.frame(
  students,
  student_heights_cm,
  gpa$gpa[1:8]
)
```

```{r}
student_survey_df <- data.frame(
  students,
  student_heights_cm,
  gpa[1:8, ]
)
```

## Try to graph

```         
## Graph
```

```{r}
ggplot(student_survey_df,
       aes(out, gpa)
) +
         geom_point()
       
```

I didn't like that graphic, it doesn't say much

ggplot needs a categorical x (or group) to split box-plots

```{r}
ggplot(student_survey_df,
       aes(factor(out), gpa)) + 
  geom_boxplot(fill = "skyblue") +
  labs(
    x = "Nights Out",
    y = "GPA",
    title = "GPA distribution by Nights out"
  )
```

# Check resources

-   <https://docs.posit.co/cloud/>
-   <https://posit.cloud/learn/recipes>
-   <https://r4ds.hadley.nz/>

## You can now:

-   Work with different sections/modules of R environment

-   Manipulate objects in R

-   Load and organize data

-   Ask questions

-   Analyze data

-   Make real plots

-   Read other people’s R code

-   Make reports

-   create reproducible R scripts

FIN
